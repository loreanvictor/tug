#!/bin/bash
set -e

#
# ‚ïã‚îì‚îè‚îè‚îì
# ‚îó‚îó‚îª‚îó‚î´
#     ‚îõ
#
# this deployment script helps manage application deployments
# on a server or a vps using systemd. it sets up a systemd service
# for each application, keeps track of releases, allowing smooth
# deploys and rollbacks.
#
# it works by keeping timestamped releases in /srv/<app>/releases,
# symlinking the "current" release to a build, and configuring the service
# to run the binary from the "current" symlink.
#

# -------- COLORS --------
COLOR_PRIM="\033[1;34m"
COLOR_SEC="\033[0;35m"
COLOR_ERR="\033[1;31m"
COLOR_SUCC="\033[1;32m"
NO_COLOR="\033[0m"
# ------------------------

usage() {
  echo ""
  echo "  ‚ïã‚îì‚îè‚îè‚îì  "
  echo "  ‚îó‚îó‚îª‚îó‚î´  "
  echo "      ‚îõ  "
  echo ""
  echo -e "${COLOR_SEC}Usage:${NO_COLOR} tug <command>"
  echo ""
  echo -e "${COLOR_SEC}Commands:${NO_COLOR}"
  echo -e "  ${COLOR_PRIM}init${NO_COLOR}        initialize deployment setup"
  echo -e "  ${COLOR_PRIM}build${NO_COLOR}       build a new release"
  echo -e "  ${COLOR_PRIM}deploy${NO_COLOR}      deploy the latest release"
  echo -e "  ${COLOR_PRIM}rollback${NO_COLOR}    roll back to a previous release"
  echo -e "  ${COLOR_PRIM}list${NO_COLOR}        list releases"
  echo -e "  ${COLOR_PRIM}current${NO_COLOR}     show current release"
  echo -e "  ${COLOR_PRIM}cleanup${NO_COLOR}     remove old releases"
  echo -e "  ${COLOR_PRIM}logs${NO_COLOR}        show recent logs"
  echo -e "  ${COLOR_PRIM}status${NO_COLOR}      show service status"
  echo -e "  ${COLOR_PRIM}reload${NO_COLOR}      reload service"
  echo ""
  exit 1
}

# ------------------------
# CONFIG LOADING
# ------------------------

load_paths() {
  SRV_ROOT="/srv"
  ETC_ROOT="/etc"

  APP_DIR="$SRV_ROOT/$APP_NAME"
  RELEASE_DIR="$APP_DIR/releases"
  DATA_DIR="$APP_DIR/data"
  CURRENT_LINK="$APP_DIR/current"
  EXEC_PATH="$CURRENT_LINK/$APP_NAME"

  ETC_DIR="$ETC_ROOT/$APP_NAME"
  ENV_FILE="$ETC_DIR/env"
  SERVICE_FILE="$ETC_ROOT/systemd/system/$APP_NAME.service"
}

require_tug_config() {
  if [ ! -f ".tug" ]; then
    echo -e "${COLOR_ERR}No .tug file found in this directory.${NO_COLOR}"
    echo "Run 'tug init' first."
    exit 1
  fi
  source .tug
  load_paths
}

timestamp() {
  date +"%Y-%m-%d_%H-%M-%S"
}

# ------------------------
# SYSTEMD BINDINGS
# ------------------------

enable_service() {
  sudo systemctl daemon-reload
  sudo systemctl enable "$APP_NAME"
}

restart_service() {
  sudo systemctl restart "$APP_NAME"
}

# ------------------------
# INIT
# ------------------------

init() {
  echo ""
  echo -e "${COLOR_SEC}Initializing new tug project...${NO_COLOR}"

  DEFAULT_NAME=$(basename "$PWD")
  read -rp "App name [$DEFAULT_NAME]: " APP_NAME
  APP_NAME="${APP_NAME:-$DEFAULT_NAME}"

  DEFAULT_BUILD_CMD="cargo build --release --bin $APP_NAME"
  read -rp "Build command [$DEFAULT_BUILD_CMD]: " BUILD_CMD
  BUILD_CMD="${BUILD_CMD:-$DEFAULT_BUILD_CMD}"

  DEFAULT_BINARY_PATH="target/release/$APP_NAME"
  read -rp "Binary output path [$DEFAULT_BINARY_PATH]: " BINARY_PATH
  BINARY_PATH="${BINARY_PATH:-$DEFAULT_BINARY_PATH}"

  cat > .tug <<EOF
# .tug ‚Äî auto-generated by tug init

APP_NAME="$APP_NAME"
BUILD_CMD="$BUILD_CMD"
BINARY_PATH="$BINARY_PATH"
KEEP_RELEASES=10
EOF

  echo -e "‚ñ∂ Created ${COLOR_PRIM}.tug${NO_COLOR}"

  # Create directories
  load_paths
  sudo mkdir -p $RELEASE_DIR
  sudo mkdir -p $DATA_DIR
  sudo chown -R "$USER:$USER" $APP_DIR
  echo -e "‚ñ∂ Created working dir: ${COLOR_PRIM}$APP_DIR${NO_COLOR}"

  # Env dir
  sudo mkdir -p $ETC_DIR
  sudo touch $ENV_FILE
  sudo chmod 600 $ENV_FILE
  echo -e "‚ñ∂ Created env file: ${COLOR_PRIM}$ENV_FILE${NO_COLOR}"

  # Systemd service
  sudo tee $SERVICE_FILE >/dev/null <<EOF
[Unit]
Description=$APP_NAME service
After=network.target

[Service]
User=$USER
WorkingDirectory=$CURRENT_LINK
ExecStart=$EXEC_PATH
EnvironmentFile=$ENV_FILE
Restart=always
RestartSec=2
KillMode=mixed

[Install]
WantedBy=multi-user.target
EOF

  enable_service

  echo ""
  echo -e "${COLOR_SUCC}‚úî Initialization complete.${NO_COLOR}"
  echo ""
}

# ------------------------
# BUILD
# ------------------------

build() {
  require_tug_config

  echo ""
  echo -e "${COLOR_SEC}Building ${COLOR_PRIM}$APP_NAME${NO_COLOR}..."
  eval $BUILD_CMD

  if [ ! -f "$BINARY_PATH" ]; then
    echo -e "${COLOR_ERR}Binary not found: $BINARY_PATH${NO_COLOR}"
    exit 1
  fi

  TS=$(timestamp)
  DEST="$RELEASE_DIR/$TS"

  mkdir -p "$DEST"
  cp "$BINARY_PATH" "$DEST/$APP_NAME"

  echo -e "‚ñ∂ Build copied to release: ${COLOR_PRIM}$DEST${NO_COLOR}"
  echo -e "${COLOR_SUCC}‚úî Build complete.${NO_COLOR}"
}

# ------------------------
# DEPLOY
# ------------------------

deploy() {
  require_tug_config

  LATEST=$(ls -1 "$RELEASE_DIR" | sort | tail -n 1)
  [ -z "$LATEST" ] && echo "No releases found." && exit 1

  echo ""
  echo -e "${COLOR_SEC}Deploying release ${COLOR_PRIM}$LATEST${NO_COLOR}"

  ln -sfn "$RELEASE_DIR/$LATEST" "$CURRENT_LINK"
  restart_service

  echo -e "üöÄ ${COLOR_SUCC}Deployment complete.${NO_COLOR}"
}

# ------------------------
# ROLLBACK
# ------------------------

rollback() {
  require_tug_config

  CURRENT=$(basename "$(readlink "$CURRENT_LINK")")

  echo ""
  echo -e "${COLOR_SEC}Select release to roll back to:${NO_COLOR}"

  if command -v fzf >/dev/null 2>&1; then
    SELECTED=$(ls -1 "$RELEASE_DIR" | sort | awk -v curr="$CURRENT" '
      $0==curr { print $0 " (current)" }
      $0!=curr { print $0 }
    ' | fzf --layout=reverse-list --height=10 --ansi)
  else
    echo "(fzf not found ‚Äî using simple menu)"
    select sel in $(ls -1 "$RELEASE_DIR" | sort); do
      SELECTED="$sel"; break
    done
  fi

  [ -z "$SELECTED" ] && echo "No selection." && exit 1
  [[ "$SELECTED" == *"(current)"* ]] && {
    echo -e "${COLOR_ERR}Already current.${NO_COLOR}"
    exit 1
  }

  echo -e "${COLOR_SEC}Rolling back to ${COLOR_PRIM}$SELECTED${NO_COLOR}"

  ln -sfn "$RELEASE_DIR/$SELECTED" "$CURRENT_LINK"
  restart_service

  echo -e "${COLOR_SUCC}‚úî Rollback complete.${NO_COLOR}"
}

# ------------------------
# LIST RELEASES
# ------------------------

list_releases() {
  require_tug_config

  CURRENT=$(basename "$(readlink "$CURRENT_LINK")")

  echo ""
  echo -e "${COLOR_SEC}Releases for${NO_COLOR} ${COLOR_PRIM}$APP_NAME${NO_COLOR}:"
  ls -1 "$RELEASE_DIR" | sort | sed "s/^$CURRENT\$/$CURRENT (current)/"
}

# ------------------------
# CURRENT RELEASE
# ------------------------

current() {
  require_tug_config
  basename "$(readlink "$CURRENT_LINK")"
}

# ------------------------
# CLEANUP
# ------------------------

cleanup() {
  require_tug_config

  TOTAL=$(ls -1 "$RELEASE_DIR" | wc -l | xargs)
  if [ "$TOTAL" -le "$KEEP_RELEASES" ]; then
    echo "Nothing to clean."
    exit 0
  fi

  REMOVE_COUNT=$((TOTAL - KEEP_RELEASES))

  echo -e "${COLOR_SEC}Removing ${COLOR_PRIM}$REMOVE_COUNT${COLOR_SEC} old releases...${NO_COLOR}"

  ls -1 "$RELEASE_DIR" | sort | head -n "$REMOVE_COUNT" | while read R; do
    rm -rf "$RELEASE_DIR/$R"
    echo "‚óÉ Removed $R"
  done

  echo -e "${COLOR_SUCC}‚úî Cleanup complete.${NO_COLOR}"
}

# ------------------------
# STATUS + LOGS
# ------------------------

status() {
  require_tug_config
  sudo systemctl status "$APP_NAME"
}

logs() {
  require_tug_config
  sudo journalctl -u "$APP_NAME" -n 50 -f
}

reload() {
  require_tug_config
  sudo systemctl daemon-reload
  sudo systemctl status "$APP_NAME"
}

# ------------------------
# MAIN
# ------------------------

CMD=$1

case "$CMD" in
  init) init ;;
  build) build ;;
  deploy) deploy ;;
  rollback) rollback ;;
  list) list_releases ;;
  current) current ;;
  cleanup) cleanup ;;
  status) status ;;
  reload) reload ;;
  logs) logs ;;
  *) usage ;;
esac
